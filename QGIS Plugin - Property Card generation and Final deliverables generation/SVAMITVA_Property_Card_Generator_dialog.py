# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SvamitvaPropertyCardGeneratorDialog
                                 A QGIS plugin
 Generates Property Card (PPM) for selected parcel shapefile
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-09-10
 ***************************************************************************/
"""

import os
import shutil

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QDialog, QFileDialog, QMessageBox
from qgis.PyQt.QtCore import QVariant, QSizeF
from qgis.PyQt.QtGui import QColor, QFont, QIcon, QPixmap   # ‚úÖ added QIcon, QPixmap
from PyQt5.QtWidgets import QFileDialog, QListView
from PyQt5.QtGui import QFontDatabase
from qgis.PyQt.QtXml import QDomDocument

from qgis import processing
from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsWkbTypes,
    QgsFeature,
    QgsField,
    QgsVectorDataProvider,
    QgsExpression,
    QgsSymbol,
    QgsFillSymbol,
    QgsLineSymbol,
    QgsMarkerSymbol,
    QgsRuleBasedRenderer,
    QgsPalLayerSettings,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextBufferSettings,
    QgsProperty,
    QgsFeatureRequest,
    QgsGeometry,
    QgsVectorFileWriter,
    QgsRuleBasedLabeling,
    QgsTextBackgroundSettings,
    QgsPrintLayout,
    QgsLayoutAtlas,
    QgsLayoutItemLabel,
    QgsReadWriteContext
)

# Load the UI
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), 'SVAMITVA_Property_Card_Generator_dialog_base.ui')
)


class SVAMITVAPropertyCardGeneratorDialog(QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        super(SVAMITVAPropertyCardGeneratorDialog, self).__init__(parent)

        self.iface = iface   # now iface is available in the dialog
        self.setupUi(self)

        # ‚úÖ Set window icon from icon.png
        icon_path = os.path.join(os.path.dirname(__file__), "icon.png")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        # Load custom fonts (from plugin/fonts folder)
        fonts_dir = os.path.join(os.path.dirname(__file__), "fonts")
        if os.path.exists(fonts_dir):
            for fname in os.listdir(fonts_dir):
                if fname.lower().endswith(".ttf"):
                    font_path = os.path.join(fonts_dir, fname)
                    font_id = QFontDatabase.addApplicationFont(font_path)
                    if font_id != -1:
                        loaded = QFontDatabase.applicationFontFamilies(font_id)
                        self.logTextEdit.append(f"‚úÖ Loaded font: {loaded}")
                    else:
                        self.logTextEdit.append(f"‚ö†Ô∏è Could not load font: {fname}")
                        
        # Connect button
        self.generatePPMsButton.clicked.connect(self.generate_ppms)
        
        self.browseButton.clicked.connect(self.browse_output_folder)

        # ‚úÖ Browse button for photos folder
        self.photosBrowseButton.clicked.connect(self.select_photos_folder)

        # Populate dropdown when dialog opens
        self.populate_parcel_layers()

    def populate_parcel_layers(self):
        """Populate dropdown with all polygon layers in the current QGIS project"""
        self.parcelLayerComboBox.clear()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if isinstance(layer, QgsVectorLayer) and layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                self.parcelLayerComboBox.addItem(layer.name(), layer.id())

    def browse_output_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "Select Output Folder")
        if folder:
            self.outputFolderLineEdit.setText(folder)

    def select_photos_folder(self):
        """Open folder picker dialog for photos source folder."""
        folder = QFileDialog.getExistingDirectory(self, "Select Photos Folder", "")
        if folder:
            self.photosFolderLineEdit.setText(folder)
            
    def load_qpt_template(self, qpt_path, parcel_layer):
        project = QgsProject.instance()
        manager = project.layoutManager()

        if not os.path.exists(qpt_path):
            self.logTextEdit.append(f"‚ö†Ô∏è QPT template not found: {qpt_path}")
            return

        try:
            layout = QgsPrintLayout(project)
            layout.initializeDefaults()

            # Parse QPT into QDomDocument
            doc = QDomDocument()
            with open(qpt_path, 'r', encoding="utf-8") as f:
                template_content = f.read()
            if not doc.setContent(template_content):
                self.logTextEdit.append("‚ùå Invalid QPT template XML.")
                return

            context = QgsReadWriteContext()
            layout.loadFromTemplate(doc, context)

            layout.setName("PropertyCard_SINGLE_SVAMITVA")
            manager.addLayout(layout)

            self.logTextEdit.append("‚úÖ Property Card template loaded successfully.")


            # ‚úÖ Configure Atlas settings
            atlas = layout.atlas()
            atlas.setEnabled(True)  # Generate an Atlas - enabled

            # Set coverage layer (must exist in project!)
            atlas.setCoverageLayer(parcel_layer)  # Coverage layer = parcel_layer

            # Page name expression
            atlas.setPageNameExpression('"PPM"')

            # Sorting
            atlas.setSortFeatures(True)
            atlas.setSortExpression('"PPM"')

            # Single file export setting
            if hasattr(atlas, "setSingleFileExportMode"):
                # QGIS 3.26+
                atlas.setSingleFileExportMode(QgsLayoutAtlas.ExportByFeature)
            else:
                try:
                    # QGIS <= 3.24
                    atlas.setSingleFile(False)  # Single file export when possible - disabled
                except Exception:
                    # If neither available, just skip
                    self.logTextEdit.append("‚ö†Ô∏è Atlas single-file export setting skipped (not supported in this QGIS).")

            # Output filename expression
            atlas.setFilenameExpression("'Property Card_' || @atlas_featurenumber")

            # ‚úÖ Now configure "Center_point_Coordinates" table
            table_frame = layout.itemById("Center_point_Coordinates")
            if table_frame:
                # Get the actual attribute table object behind the frame
                table_item = table_frame.multiFrame()
                
                # Make sure your center_point layer is already added to project before this
                center_point = QgsProject.instance().mapLayersByName(f"{parcel_layer.name()}__center_point")
                if center_point:
                    center_point_layer = center_point[0]

                    # Set the source of the table to the center point layer
                    table_item.setVectorLayer(center_point_layer)

                    # Keep only Easting_X and Northing_Y fields
                    fields_to_show = ["Easting_X", "Northing_Y"]
                    table_item.setDisplayedFields(fields_to_show)

                    self.logTextEdit.append("‚úÖ Table 'Center_point_Coordinates' updated with Easting/ Northing only.")
                else:
                    self.logTextEdit.append("‚ö†Ô∏è Center point layer not found in project.")
            else:
                self.logTextEdit.append("‚ö†Ô∏è No table item named 'Center_point_Coordinates' in template.")

            # ‚úÖ Open layout in designer and preview first feature
            self.iface.openLayoutDesigner(layout)
            
            self.logTextEdit.append("‚úÖ Property Card template loaded & Atlas configured successfully.")
            
        except Exception as e:
            self.logTextEdit.append(f"‚ùå Error loading QPT template or configuring Atlas: {e}")
                        
    def generate_ppms(self):
        """Full pipeline run when Generate PPMs clicked."""
        try:

            # 1. Collect user inputs
            district = self.districtComboBox.currentText().strip()
            mandal = self.mandalLineEdit.text().strip()
            village = self.villageLineEdit.text().strip()
            lgd_code = self.lgdLineEdit.text().strip()
            base_folder = self.outputFolderLineEdit.text().strip()
            photos_source = self.photosFolderLineEdit.text().strip()

            if not (district and mandal and village and lgd_code and base_folder):
                QMessageBox.warning(self, "Missing Input", "‚ö†Ô∏è Please fill all fields and select output folder.")
                return

            # 2. Create structured folder path
            # Main structured folder
            out_dir = os.path.join(base_folder, district, mandal, f"{village}_{lgd_code}")
            os.makedirs(out_dir, exist_ok=True)

            # Subfolder for shapefiles
            out_dir_shapefiles = os.path.join(out_dir, "shapefiles")
            os.makedirs(out_dir_shapefiles, exist_ok=True)
            self.logTextEdit.append(f"üìÇ Output directory created: {out_dir}")
            self.logTextEdit.append(f"üìÇ Shapefiles Output directory created: {out_dir_shapefiles}")

            # ‚úÖ Switch to Log tab immediately
            try:
                # If your QTabWidget is named tabWidget and Log is the 2nd tab (index 1)
                self.tabWidget.setCurrentIndex(1)
            except Exception as e:
                print("Could not switch to Log tab:", e)
                
            # UI feedback start
            self.progressBar.setValue(0)
            self.logTextEdit.clear()
            self.logTextEdit.append("Starting PPM generation pipeline...")

            # 1) Selected parcel layer
            parcel_layer_id = self.parcelLayerComboBox.currentData()
            orig_parcel_layer = QgsProject.instance().mapLayer(parcel_layer_id)

            if orig_parcel_layer is None:
                self.logTextEdit.append("‚ùå No parcel layer selected.")
                return

            # Define output shapefile path for parcel layer
            parcel_out_path = os.path.join(out_dir_shapefiles, f"{village}_{lgd_code}.shp")

            # Save the selected layer into the structured folder
            try:
                _error, _error_msg = QgsVectorFileWriter.writeAsVectorFormat(
                    orig_parcel_layer,
                    parcel_out_path,
                    "UTF-8",
                    orig_parcel_layer.crs(),
                    "ESRI Shapefile"
                )

                if _error == QgsVectorFileWriter.NoError:
                    self.logTextEdit.append(f"‚úÖ Parcel layer saved as: {parcel_out_path}")
                else:
                    self.logTextEdit.append(f"‚ö†Ô∏è Error saving parcel layer: {_error}, {_error_msg}")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Exception saving parcel layer: {e}")
                return

            # Reload from saved shapefile so pipeline always uses this copy
            parcel_layer = QgsVectorLayer(parcel_out_path, f"{village}_{lgd_code}", "ogr")
            if not parcel_layer.isValid():
                self.logTextEdit.append("‚ùå Reloaded parcel layer is invalid.")
                return

            QgsProject.instance().addMapLayer(parcel_layer)
            self.logTextEdit.append(f"Selected parcel layer: {parcel_layer.name()}")
            self.progressBar.setValue(5)

            # 5. Copy photos folder into village folder
            photos_dest = os.path.join(out_dir, "Photos")
            if os.path.exists(photos_source):
                shutil.copytree(photos_source, photos_dest, dirs_exist_ok=True)
                self.logTextEdit.append(f"üìÇ Photos copied to: {photos_dest}")
            else:
                self.logTextEdit.append("‚ö†Ô∏è No source photos folder found.")

            # 6. Add "PhotoPath" field if not exists
            provider = parcel_layer.dataProvider()
            if "PhotoPath" not in [f.name() for f in parcel_layer.fields()]:
                provider.addAttributes([QgsField("PhotoPath", QVariant.String, len=255)])
                parcel_layer.updateFields()

            # 7. Update each feature with photo path (match PPM to filename)
            parcel_layer.startEditing()
            for feature in parcel_layer.getFeatures():
                ppm_value = str(feature["PPM"]).strip()  # safety: cast to string
                if not ppm_value:
                    continue

                # Check possible photo names
                candidates = [
                    os.path.join(photos_dest, f"{ppm_value}.jpg"),
                    os.path.join(photos_dest, f"{ppm_value}.jpeg"),
                    os.path.join(photos_dest, f"{ppm_value}.JPG"),
                    os.path.join(photos_dest, f"{ppm_value}.JPEG"),
                ]

                photo_file = None
                for c in candidates:
                    if os.path.exists(c):
                        # Normalize slashes for QGIS
                        photo_file = c.replace("\\", "/")
                        break

                if photo_file:
                    parcel_layer.changeAttributeValue(
                        feature.id(),
                        parcel_layer.fields().indexFromName("PhotoPath"),
                        photo_file
                    )
            parcel_layer.commitChanges()

            self.logTextEdit.append("‚úÖ Photo paths added to parcel layer successfully.")
            self.progressBar.setValue(10)
            
            # 4. Helper to run algorithm and save as shapefile
            def run_and_save(alg, params, out_name):
                out_path = os.path.join(out_dir_shapefiles, f"{out_name}.shp")
                params['OUTPUT'] = out_path
                res = processing.run(alg, params)
                layer = QgsVectorLayer(out_path, out_name, "ogr")
                if not layer.isValid():
                    self.logTextEdit.append(f"‚ùå Failed to create {out_name}")
                else:
                    QgsProject.instance().addMapLayer(layer)
                    self.logTextEdit.append(f"‚úÖ {out_name} saved: {out_path}")
                return layer

            # 3) Boundary
            self.logTextEdit.append("1/12 ‚Üí Creating boundary...")
            # Define output file path in structured folder
            boundary_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_boundary.shp")

            params = {
                'INPUT': parcel_layer,
                'OUTPUT': boundary_path  # save to file instead of memory
            }
            res = processing.run("native:boundary", params)
            boundary_layer = QgsVectorLayer(boundary_path, f"{parcel_layer.name()}__boundary", "ogr")
            QgsProject.instance().addMapLayer(boundary_layer)
            self.logTextEdit.append(f"Boundary created and saved: {boundary_layer.name()}")

            # 4) Explode lines from boundary
            self.logTextEdit.append("2/12 ‚Üí Exploding lines from boundary...")
            # Define output path for exploded lines
            explode_lines_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_explode_lines.shp")

            res = processing.run("native:explodelines", {
                'INPUT': boundary_layer,
                'OUTPUT': explode_lines_path
            })

            # Load the saved shapefile into the project
            explode_lines = QgsVectorLayer(explode_lines_path, f"{parcel_layer.name()}__explode_lines", "ogr")
            QgsProject.instance().addMapLayer(explode_lines)

            self.logTextEdit.append(f"Explode lines created and saved: {explode_lines.name()}")
            self.progressBar.setValue(25)


            # 5) Extract vertices from boundary
            self.logTextEdit.append("3/12 ‚Üí Extracting vertices from boundary...")
            # Define output path for vertices
            vertices_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_vertices.shp")

            res = processing.run("native:extractvertices", {
                'INPUT': boundary_layer,
                'OUTPUT': vertices_path
            })

            # Load the saved vertices shapefile
            vertices = QgsVectorLayer(vertices_path, f"{parcel_layer.name()}__vertices", "ogr")
            QgsProject.instance().addMapLayer(vertices)

            self.logTextEdit.append(f"Vertices layer created and saved: {vertices.name()}")
            self.progressBar.setValue(35)


            # 6) Set rule-based symbology and labeling for parcel layer
            self.logTextEdit.append("4/12 ‚Üí Applying symbology and labeling to parcel layer...")
            try:
                # Root of rule-based renderer (no symbol)
                root_rule = QgsRuleBasedRenderer.Rule(None)

                # 6a) atlas intersection rule (transparent fill)
                exp1 = 'CASE WHEN within($geometry, @atlas_geometry)=0 THEN intersects($geometry, @atlas_geometry)=1 ELSE NULL END'
                sym1 = QgsFillSymbol.createSimple({'color': '255,255,255,0', 'outline_color': '0,0,0,0'})
                rule1 = QgsRuleBasedRenderer.Rule(sym1)
                rule1.setFilterExpression(exp1)
                rule1.setDescription('atlas_intersect')
                root_rule.appendChild(rule1)

                # 6b) PPM outline rule
                exp2 = '"PPM" = @atlas_pagename'
                fill_sym = QgsFillSymbol.createSimple({'color': '255,255,255,0'})
                outline = QgsLineSymbol.createSimple({'color': '0,0,0', 'width': '0.6'})
                try:
                    fill_sym.appendSymbolLayer(outline.symbolLayer(0).clone())
                except Exception:
                    pass
                rule2 = QgsRuleBasedRenderer.Rule(fill_sym)
                rule2.setFilterExpression(exp2)
                rule2.setDescription('PPM_outline')
                root_rule.appendChild(rule2)

                renderer = QgsRuleBasedRenderer(root_rule)
                parcel_layer.setRenderer(renderer)
                parcel_layer.triggerRepaint()

                # ---------- Rule A (PPM label) ----------
                pal_a = QgsPalLayerSettings()
                pal_a.enabled = True
                pal_a.fieldName = "\"PPM\""
                pal_a.isExpression = True
                pal_a.placement = QgsPalLayerSettings.OverPoint
                pal_a.centroidInside = True          # force label centroid inside polygon
                pal_a.priority = 10                  # high priority
                pal_a.obstacle = True                # treat features as obstacles
                pal_a.obstacleFactor = 1.0           # how strongly labels avoid obstacles

                tf_a = QgsTextFormat()
                tf_a.setFont(QFont("Arial", 15, QFont.Bold))
                # tf_a.setSize(8)
                tf_a.setColor(QColor('black'))

                # ‚úÖ Circular background
                bg = QgsTextBackgroundSettings()
                bg.setEnabled(True)               # enable background
                bg.setType(QgsTextBackgroundSettings.ShapeCircle)   # set circle shape
                bg.strokeWidth = 0.3
                bg.sizeType = QgsTextBackgroundSettings.SizeBuffer
                bg.setSize(QSizeF(0.5, 0.5))  # width x height in millimeters

                # Fill symbol setup
                fill_sym = QgsFillSymbol.createSimple({
                    'style': 'solid',        # stroke style
                    'color': '255,255,255,0',# transparent fill (RGBA)
                    'outline_color': '0,0,0',# stroke color black
                    'outline_width': '0.3'   # stroke width
                })
                bg.setFillSymbol(fill_sym)
             
                tf_a.setBackground(bg)

                pal_a.setFormat(tf_a)

                rule_a = QgsRuleBasedLabeling.Rule(pal_a, description="PPM label")
                rule_a.setFilterExpression('"PPM" = @atlas_pagename')


                # ---------- Rule B (Else label) ----------
                pal_b = QgsPalLayerSettings()
                pal_b.enabled = True
                pal_b.fieldName = "\"PPM\""
                pal_b.isExpression = True
                pal_b.placement = QgsPalLayerSettings.OverPoint
                pal_b.centroidInside = True
                pal_b.priority = 10
                pal_b.dist = 1                      # 1 mm distance
                pal_b.obstacle = True
                pal_b.obstacleFactor = 1.0

                tf_b = QgsTextFormat()
                # Create font with bold + underline
                font = QFont("Arial", 15, QFont.Bold)
                font.setUnderline(True)   # ‚úÖ underline applied here

                tf_b.setFont(font)
                # tf_b.setSize(8)
                tf_b.setColor(QColor('black'))
                pal_b.setFormat(tf_b)

                rule_b = QgsRuleBasedLabeling.Rule(pal_b, description="Else label", elseRule=True)

                # Combine rules
                root_label = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
                root_label.appendChild(rule_a)
                root_label.appendChild(rule_b)

                labeling = QgsRuleBasedLabeling(root_label)
                parcel_layer.setLabeling(labeling)
                parcel_layer.setLabelsEnabled(True)
                parcel_layer.triggerRepaint()


                self.logTextEdit.append("Parcel symbology and base labeling applied (please fine-tune labels visually).")

            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Symbology/labeling step raised an error: {e}")

            self.progressBar.setValue(45)

            # 7) Multi-ring buffer around vertices (number of rings=1, distance=2)
            # Define output path for buffer
            buffer_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_buffer.shp")

            self.logTextEdit.append("5/12 ‚Üí Creating multi-ring buffer (distance 2, rings 1) around vertices...")

            # Try native:multiringbuffer first, fallback to buffer
            try:
                res = processing.run("native:multiringbuffer", {
                    'INPUT': vertices,
                    'DISTANCE': 2,
                    'NUMBER': 1,
                    'SEGMENTS': 8,
                    'OUTPUT': buffer_path
                })
            except Exception:
                res = processing.run("native:buffer", {
                    'INPUT': vertices,
                    'DISTANCE': 2,
                    'SEGMENTS': 8,
                    'DISSOLVE': False,
                    'OUTPUT': buffer_path
                })

            # Load the saved buffer shapefile
            buffer_layer = QgsVectorLayer(buffer_path, f"{parcel_layer.name()}__buffer", "ogr")
            QgsProject.instance().addMapLayer(buffer_layer)

            self.logTextEdit.append(f"Buffer created and saved: {buffer_layer.name()}")
            self.progressBar.setValue(55)


            # 8) Clip: explode_lines (input) clipped by buffer
            # Define output path for clip layer
            clip_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_clip.shp")

            self.logTextEdit.append("6/12 ‚Üí Clipping exploded lines by buffer...")

            # Run clipping and save directly to file
            res = processing.run("native:clip", {
                'INPUT': explode_lines,
                'OVERLAY': buffer_layer,
                'OUTPUT': clip_path
            })

            # Load the saved clip shapefile
            clip_layer = QgsVectorLayer(clip_path, f"{parcel_layer.name()}__clip", "ogr")
            QgsProject.instance().addMapLayer(clip_layer)

            self.logTextEdit.append(f"Clip created and saved: {clip_layer.name()}")
            self.progressBar.setValue(65)


            # 9) Explode lines for the clip shapefile
            # Define output path for clip_explode_lines
            clip_explode_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_clip_explode_lines.shp")

            self.logTextEdit.append("7/12 ‚Üí Exploding lines from clip...")

            # Run explode lines and save directly to shapefile
            res = processing.run("native:explodelines", {
                'INPUT': clip_layer,
                'OUTPUT': clip_explode_path
            })

            # Load the saved shapefile as a layer
            clip_explode_lines = QgsVectorLayer(clip_explode_path, f"{parcel_layer.name()}__clip_explode_lines", "ogr")
            QgsProject.instance().addMapLayer(clip_explode_lines)

            self.logTextEdit.append(f"Clip explode lines created and saved: {clip_explode_lines.name()}")
            self.progressBar.setValue(70)


            # 10) Change symbology on the explode_lines (from boundary) -> rule-based with transparency 0% for PPM = @atlas_pagename
            self.logTextEdit.append("8/12 ‚Üí Applying symbology to explode lines (boundary-derived)...")
            try:
                root = QgsRuleBasedRenderer.Rule(None)
                exp_ppm = '"PPM" = @atlas_pagename'
                # create a transparent symbol (opacity 0)
                sym = QgsLineSymbol.createSimple({'color': '0,0,0', 'width': '0.26'})
                sym.setOpacity(0.0)
                rule = QgsRuleBasedRenderer.Rule(sym)
                rule.setFilterExpression(exp_ppm)
                rule.setDescription('hide_ppm')
                root.appendChild(rule)
                expl_renderer = QgsRuleBasedRenderer(root)
                explode_lines.setRenderer(expl_renderer)
                explode_lines.triggerRepaint()
                self.logTextEdit.append("Explode lines symbology applied.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Explode lines symbology error: {e}")

            self.progressBar.setValue(75)

            # 11) Add new field "length" to explode_lines and populate with $length (Decimal number, length=10, precision=2)
            self.logTextEdit.append("9/12 ‚Üí Adding 'length' field to explode lines and populating values...")
            try:
                if explode_lines.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
                    explode_lines.startEditing()
                    # create field with length and precision
                    fld = QgsField("length", QVariant.Double, '', 10, 2)
                    explode_lines.dataProvider().addAttributes([fld])
                    explode_lines.updateFields()

                    idx = explode_lines.fields().indexFromName('length')
                    for feat in explode_lines.getFeatures():
                        geom = feat.geometry()
                        if geom is None:
                            continue
                        length_value = geom.length()
                        # round to 2 decimal places for the precision
                        explode_lines.changeAttributeValue(feat.id(), idx, round(float(length_value), 2))
                    explode_lines.commitChanges()
                    self.logTextEdit.append("Length field added (Double, width=10, prec=2) and populated.")
                else:
                    self.logTextEdit.append("‚ö†Ô∏è Cannot add field to explode_lines (provider doesn't support add).")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error adding/calculating length: {e}")

            self.progressBar.setValue(80)

            # 12) Label explode_lines with length (Single Labels), with size expression and placement.
            self.logTextEdit.append("10/12 ‚Üí Applying labeling to explode lines (show 'length')...")
            try:
                pal = QgsPalLayerSettings()
                pal.enabled = True
                pal.fieldName = 'length'
                pal.isExpression = False
                try:
                    pal.placement = QgsPalLayerSettings.Line
                except Exception:
                    pass
                try:
                    pal.distance = 1  # mm (approx)
                except Exception:
                    pass
                text_format = QgsTextFormat()
                text_format.setFont(QFont("Arial", 8))
                text_format.setSize(8)
                pal.setFormat(text_format)

                labeling = QgsVectorLayerSimpleLabeling(pal)
                explode_lines.setLabeling(labeling)
                explode_lines.setLabelsEnabled(True)
                explode_lines.triggerRepaint()
                self.logTextEdit.append("Labels applied to explode lines.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Labeling explode lines error: {e}")

            # 13) Clip explode lines symbology rule-based
            self.logTextEdit.append("11/12 ‚Üí Applying symbology to clip explode lines...")
            try:
                rootc = QgsRuleBasedRenderer.Rule(None)
                exp_clip = 'CASE WHEN within($geometry, @atlas_geometry)=0 THEN intersects($geometry, @atlas_geometry)=1 ELSE NULL END'
                symc = QgsLineSymbol.createSimple({'color': '0,0,0', 'width': '0.26'})
                rulec = QgsRuleBasedRenderer.Rule(symc)
                rulec.setFilterExpression(exp_clip)
                rulec.setDescription('clip_rule')
                rootc.appendChild(rulec)
                clip_explode_lines.setRenderer(QgsRuleBasedRenderer(rootc))
                clip_explode_lines.triggerRepaint()
                self.logTextEdit.append("Clip explode lines symbology applied.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Clip explode lines symbology error: {e}")

            self.progressBar.setValue(85)

            # 14) In vertices: add point_ID, Easting_X, Northing_Y fields and populate
            self.logTextEdit.append("12/12 ‚Üí Adding point_ID, Easting_X, Northing_Y fields to vertices and populating...")
            try:
                if vertices.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
                    vertices.startEditing()
                    # add fields if not present: point_ID (int len 10), Easting_X (double len15 prec3), Northing_Y (double len15 prec3)
                    fdefs = []
                    if vertices.fields().indexFromName("point_ID") == -1:
                        fdefs.append(QgsField("point_ID", QVariant.Int, '', 10, 0))
                    if vertices.fields().indexFromName("Easting_X") == -1:
                        fdefs.append(QgsField("Easting_X", QVariant.Double, '', 15, 3))
                    if vertices.fields().indexFromName("Northing_Y") == -1:
                        fdefs.append(QgsField("Northing_Y", QVariant.Double, '', 15, 3))
                    if fdefs:
                        vertices.dataProvider().addAttributes(fdefs)
                    vertices.updateFields()
                    idx_pid = vertices.fields().indexFromName("point_ID")
                    idx_e = vertices.fields().indexFromName("Easting_X")
                    idx_n = vertices.fields().indexFromName("Northing_Y")
                    # populate values: vertex index + 1, and $x/$y
                    for i, feat in enumerate(vertices.getFeatures()):
                        geom = feat.geometry()
                        if geom is None:
                            continue
                        pt = None
                        try:
                            pt = geom.asPoint()
                        except Exception:
                            try:
                                pt = geom.centroid().asPoint()
                            except Exception:
                                pt = None
                        if pt:
                            if idx_pid != -1:
                                vertices.changeAttributeValue(feat.id(), idx_pid, i + 1)
                            if idx_e != -1:
                                vertices.changeAttributeValue(feat.id(), idx_e, round(pt.x(), 3))
                            if idx_n != -1:
                                vertices.changeAttributeValue(feat.id(), idx_n, round(pt.y(), 3))
                    vertices.commitChanges()
                    self.logTextEdit.append("Vertices fields added and populated.")
                else:
                    self.logTextEdit.append("‚ö†Ô∏è Cannot add fields to vertices (provider doesn't support add).")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error adding/populating vertex fields: {e}")

            self.progressBar.setValue(90)

            # 15) Delete duplicates in vertices by (PPM, Easting_X, Northing_Y) -> manual dedupe
            self.logTextEdit.append("Removing duplicate vertices by (PPM, Easting_X, Northing_Y)...")
            try:
                # build unique key set
                seen = set()
                unique_feats = []
                fields = vertices.fields()
                ppm_idx = fields.indexFromName("PPM") if fields.indexFromName("PPM") != -1 else -1
                ex_idx = fields.indexFromName("Easting_X")
                ny_idx = fields.indexFromName("Northing_Y")

                for feat in vertices.getFeatures():
                    ppm_val = feat.attribute(ppm_idx) if ppm_idx != -1 else None
                    ex = feat.attribute(ex_idx)
                    ny = feat.attribute(ny_idx)
                    key = (ppm_val, round(float(ex) if ex is not None else 0, 3), round(float(ny) if ny is not None else 0, 3))
                    if key in seen:
                        continue
                    seen.add(key)
                    unique_feats.append(feat)

                # Define output path for no-duplicate vertices
                no_dup_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_no_dup_vertices.shp")

                # Create memory layer
                no_dup = QgsVectorLayer("Point?crs=" + vertices.crs().authid(),
                                        f"{parcel_layer.name()}__no_dup_vertices",
                                        "memory")
                no_dup_dp = no_dup.dataProvider()
                no_dup_dp.addAttributes(vertices.fields())
                no_dup.updateFields()
                no_dup.startEditing()

                for f in unique_feats:
                    newf = QgsFeature(no_dup.fields())
                    newf.setGeometry(f.geometry())
                    for idx in range(len(no_dup.fields())):
                        fldname = no_dup.fields()[idx].name()
                        newf.setAttribute(idx, f.attribute(fldname))
                    no_dup.addFeature(newf)

                no_dup.commitChanges()

                # Save the memory layer to shapefile
                _error, _error_message = QgsVectorFileWriter.writeAsVectorFormat(
                    no_dup,
                    no_dup_path,
                    "UTF-8",
                    no_dup.crs(),
                    "ESRI Shapefile"
                )

                if _error == QgsVectorFileWriter.NoError:
                    self.logTextEdit.append(f"‚úÖ No-duplicate vertices layer created and saved: {no_dup_path}")
                    # Load the saved shapefile as layer
                    no_dup_layer = QgsVectorLayer(no_dup_path, f"{parcel_layer.name()}__no_dup_vertices", "ogr")
                    QgsProject.instance().addMapLayer(no_dup_layer)

                    # --- Apply rule-based symbology to the FINAL loaded layer ---
                    rootv = QgsRuleBasedRenderer.Rule(None)
                    exp_v = '"PPM" = @atlas_pagename'
                    symv = QgsMarkerSymbol.createSimple({
                        'name': 'circle',
                        'color': '0,0,0',
                        'outline_color': '0,0,0',
                        'size': '1.00'
                    })
                    rv = QgsRuleBasedRenderer.Rule(symv)
                    rv.setFilterExpression(exp_v)
                    rv.setDescription('ppm_points')
                    rootv.appendChild(rv)

                    renderer = QgsRuleBasedRenderer(rootv)
                    no_dup_layer.setRenderer(renderer)
                    no_dup_layer.triggerRepaint()
                    self.logTextEdit.append("üé® Symbology applied to no-duplicate vertices layer.")

                else:
                    self.logTextEdit.append(f"‚ö†Ô∏è Error saving no-duplicate vertices layer: {_error}, {_error_message}")

            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error in duplicate-removal: {e}")

            self.progressBar.setValue(95)


            # 16) Apply rule-based symbology to no-duplicate vertices (simple marker black 1.00 mm where PPM=@atlas_pagename)
            try:
                rootv = QgsRuleBasedRenderer.Rule(None)
                exp_v = '"PPM" = @atlas_pagename'
                symv = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': '0,0,0', 'outline_color': '0,0,0', 'size': '1.00'})
                rv = QgsRuleBasedRenderer.Rule(symv)
                rv.setFilterExpression(exp_v)
                rv.setDescription('ppm_points')
                rootv.appendChild(rv)
                no_dup.setRenderer(QgsRuleBasedRenderer(rootv))
                no_dup.triggerRepaint()
                self.logTextEdit.append("No-duplicate vertices symbology applied.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error applying symbology to no-dup vertices: {e}")

            # 17) Uncheck/hide temporary layers (buffer, clip, boundary, vertices, orig_parcel_layer)
            self.logTextEdit.append("Hiding intermediate layers (buffer, clip, boundary, vertices, original parcel layer)...")
            try:
                for lay in (buffer_layer, clip_layer, boundary_layer, vertices, orig_parcel_layer):
                    if lay:
                        node = QgsProject.instance().layerTreeRoot().findLayer(lay.id())
                        if node:
                            node.setItemVisibilityChecked(False)
                self.logTextEdit.append("Intermediate layers (and original parcel layer) hidden.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Hide intermediate layers error: {e}")


            # 18) Reorder layers: no_dup_vertices, parcel_area, clip_explode_lines, explode_lines
            self.logTextEdit.append("Reordering layers...")
            try:
                root = QgsProject.instance().layerTreeRoot()
                layer_order = [no_dup.id(), parcel_layer.id(), clip_explode_lines.id(), explode_lines.id()]
                # move so that first in list becomes top
                for i, lid in enumerate(layer_order):
                    layer = QgsProject.instance().mapLayer(lid)
                    if layer:
                        node = root.findLayer(lid)
                        if node:
                            root.insertChildNode(i, node.clone())
                            root.removeChildNode(node)
                self.logTextEdit.append("Layer order updated.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error reordering layers: {e}")

            # 19) Point on surface for parcel_area
            self.logTextEdit.append("Generating center point (point on surface) for parcel area...")

            # Build output path
            center_point_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_center_point.shp")

            try:
                res = processing.run("native:pointonsurface", {
                    'INPUT': parcel_layer,
                    'OUTPUT': center_point_path
                })

                # Load saved center point layer
                center_point = QgsVectorLayer(center_point_path, f"{parcel_layer.name()}__center_point", "ogr")
                if not center_point.isValid():
                    raise Exception("Center point layer failed to load!")

                QgsProject.instance().addMapLayer(center_point)
                self.logTextEdit.append(f"‚úÖ Center point created and saved: {center_point_path}")

                # --- Step 20: styling & fields for center_point ---
                try:
                    if center_point.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
                        center_point.startEditing()
                        fdefs = []
                        if center_point.fields().indexFromName("point_ID") == -1:
                            fdefs.append(QgsField("point_ID", QVariant.Int, '', 10, 0))
                        if center_point.fields().indexFromName("Easting_X") == -1:
                            fdefs.append(QgsField("Easting_X", QVariant.Double, '', 15, 3))
                        if center_point.fields().indexFromName("Northing_Y") == -1:
                            fdefs.append(QgsField("Northing_Y", QVariant.Double, '', 15, 3))
                        if fdefs:
                            center_point.dataProvider().addAttributes(fdefs)
                        center_point.updateFields()

                        idx_pid = center_point.fields().indexFromName("point_ID")
                        idx_e = center_point.fields().indexFromName("Easting_X")
                        idx_n = center_point.fields().indexFromName("Northing_Y")

                        has_vertex_ind = center_point.fields().indexFromName("vertex_ind") != -1
                        for i, feat in enumerate(center_point.getFeatures()):
                            geom = feat.geometry()
                            if not geom:
                                continue
                            try:
                                pt = geom.asPoint()
                            except Exception:
                                try:
                                    pt = geom.centroid().asPoint()
                                except Exception:
                                    pt = None

                            if idx_pid != -1:
                                if has_vertex_ind:
                                    try:
                                        val = int(feat.attribute("vertex_ind")) + 1
                                        center_point.changeAttributeValue(feat.id(), idx_pid, val)
                                    except Exception:
                                        center_point.changeAttributeValue(feat.id(), idx_pid, i + 1)
                                else:
                                    center_point.changeAttributeValue(feat.id(), idx_pid, i + 1)
                            if pt:
                                if idx_e != -1:
                                    center_point.changeAttributeValue(feat.id(), idx_e, round(pt.x(), 3))
                                if idx_n != -1:
                                    center_point.changeAttributeValue(feat.id(), idx_n, round(pt.y(), 3))

                        center_point.commitChanges()

                    # üé® Styling
                    red = QgsMarkerSymbol.createSimple({'name': 'circle', 'size': '2.0', 'color': '#ff0000'})
                    white = QgsMarkerSymbol.createSimple({'name': 'circle', 'size': '1.0',
                                                        'color': '255,255,255', 'outline_color': '0,0,0'})

                    symbol = red.clone()
                    symbol.appendSymbolLayer(white.symbolLayer(0).clone())

                    rootp = QgsRuleBasedRenderer.Rule(None)

                    # ‚úÖ safer filter: only apply if "PPM" exists
                    if center_point.fields().indexFromName("PPM") != -1:
                        rulep = QgsRuleBasedRenderer.Rule(symbol)
                        rulep.setFilterExpression('"PPM" = @atlas_pagename')
                        rulep.setDescription('center_ppm')
                        rootp.appendChild(rulep)
                    else:
                        # fallback: show all points if PPM field missing
                        rulep = QgsRuleBasedRenderer.Rule(symbol)
                        rulep.setDescription('all_points')
                        rootp.appendChild(rulep)

                    renderer = QgsRuleBasedRenderer(rootp)
                    center_point.setRenderer(renderer)
                    center_point.triggerRepaint()

                    self.logTextEdit.append("üé® Center point symbology applied.")

                except Exception as e_cp_field:
                    self.logTextEdit.append(f"‚ö†Ô∏è Error adding/populating center point fields: {e_cp_field}")

            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Point on surface error: {e}")

            try:
                project = QgsProject.instance()
                project_filename = os.path.join(out_dir, f"{village}_{lgd_code}_PropertyCard.qgz")
                project.write(project_filename)
                self.logTextEdit.append(f"üíæ QGIS project saved: {project_filename}")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error saving QGIS project: {e}")

            # Load QPT layout template
            qpt_path = os.path.join(os.path.dirname(__file__), "PropertyCard_SINGLE_SVAMITVA.qpt")
            self.load_qpt_template(qpt_path, parcel_layer)
            self.logTextEdit.append(f"üëç QGIS Template saved: PropertyCard_SINGLE_SVAMITVA.qpt")

            self.progressBar.setValue(100)
            self.logTextEdit.append("‚úÖ PPM generation pipeline completed.")

        except Exception as e:
            self.logTextEdit.append(f"‚ùå Unexpected error: {e}")
            raise