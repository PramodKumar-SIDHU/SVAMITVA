# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SvamitvaPropertyCardGeneratorDialog
                                 A QGIS plugin
 Generates Property Card (PPM) for selected parcel shapefile
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-09-10
 ***************************************************************************/
"""

import os
import shutil

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import QDialog, QFileDialog, QMessageBox
from qgis.PyQt.QtCore import QVariant, QSizeF
from qgis.PyQt.QtGui import QColor, QFont, QIcon, QPixmap   # ‚úÖ added QIcon, QPixmap
from PyQt5.QtWidgets import QFileDialog, QListView
from PyQt5.QtGui import QFontDatabase
from qgis.PyQt.QtXml import QDomDocument
from PyQt5.QtCore import QTimer

from qgis import processing
from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsWkbTypes,
    QgsFeature,
    QgsField,
    QgsVectorDataProvider,
    QgsExpression,
    QgsSymbol,
    QgsFillSymbol,
    QgsLineSymbol,
    QgsMarkerSymbol,
    QgsRuleBasedRenderer,
    QgsPalLayerSettings,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextBufferSettings,
    QgsProperty,
    QgsFeatureRequest,
    QgsGeometry,
    QgsVectorFileWriter,
    QgsRuleBasedLabeling,
    QgsTextBackgroundSettings,
    QgsPrintLayout,
    QgsLayoutAtlas,
    QgsLayoutItemLabel,
    QgsReadWriteContext,
    QgsPropertyCollection,
    QgsUnitTypes,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform
)

# Load the UI
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), 'SVAMITVA_Property_Card_Generator_dialog_base.ui')
)


class SVAMITVAPropertyCardGeneratorDialog(QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        super(SVAMITVAPropertyCardGeneratorDialog, self).__init__(parent)

        self.iface = iface   # now iface is available in the dialog
        self.setupUi(self)

        # ‚úÖ Set window icon from icon.png
        icon_path = os.path.join(os.path.dirname(__file__), "icon.png")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        # Load custom fonts (from plugin/fonts folder)
        fonts_dir = os.path.join(os.path.dirname(__file__), "fonts")
        if os.path.exists(fonts_dir):
            for fname in os.listdir(fonts_dir):
                if fname.lower().endswith(".ttf"):
                    font_path = os.path.join(fonts_dir, fname)
                    font_id = QFontDatabase.addApplicationFont(font_path)
                    if font_id != -1:
                        loaded = QFontDatabase.applicationFontFamilies(font_id)
                        self.logTextEdit.append(f"‚úÖ Loaded font: {loaded}")
                    else:
                        self.logTextEdit.append(f"‚ö†Ô∏è Could not load font: {fname}")
                        
        # Connect button
        self.generatePPMsButton.clicked.connect(self.generate_ppms)
        
        self.browseButton.clicked.connect(self.browse_output_folder)

        # ‚úÖ Browse button for photos folder
        self.photosBrowseButton.clicked.connect(self.select_photos_folder)
        
        # ‚úÖ Browse button for Attributes Excel folder
        self.excelPathBrowseButton.clicked.connect(self.select_excel_file)

        # Populate dropdown when dialog opens
        self.populate_parcel_layers()

    def populate_parcel_layers(self):
        """Populate dropdown with all polygon layers in the current QGIS project"""
        self.parcelLayerComboBox.clear()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if isinstance(layer, QgsVectorLayer) and layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                self.parcelLayerComboBox.addItem(layer.name(), layer.id())

    def browse_output_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "Select Output Folder")
        if folder:
            self.outputFolderLineEdit.setText(folder)

    def select_photos_folder(self):
        """Open folder picker dialog for photos source folder."""
        folder = QFileDialog.getExistingDirectory(self, "Select Photos Folder", "")
        if folder:
            self.photosFolderLineEdit.setText(folder)

    def select_excel_file(self):
        """Open file dialog to select Excel file and set in line edit."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Excel File",
            "",
            "Excel files (*.xlsx *.xls);;All files (*.*)"
        )
        if file_path:
            self.excelPathLineEdit.setText(file_path)
                        
    def load_qpt_template(self, qpt_path, parcel_layer):
        project = QgsProject.instance()
        manager = project.layoutManager()

        if not os.path.exists(qpt_path):
            self.logTextEdit.append(f"‚ö†Ô∏è QPT template not found: {qpt_path}")
            return

        try:
            layout = QgsPrintLayout(project)
            layout.initializeDefaults()

            # Parse QPT into QDomDocument
            doc = QDomDocument()
            with open(qpt_path, 'r', encoding="utf-8") as f:
                template_content = f.read()
            if not doc.setContent(template_content):
                self.logTextEdit.append("‚ùå Invalid QPT template XML.")
                return

            context = QgsReadWriteContext()
            layout.loadFromTemplate(doc, context)

            layout.setName("PropertyCard_SINGLE_SVAMITVA")
            manager.addLayout(layout)

            self.logTextEdit.append("‚úÖ Property Card template loaded successfully.")


            # ‚úÖ Configure Atlas settings
            atlas = layout.atlas()
            atlas.setEnabled(True)  # Generate an Atlas - enabled

            # Set coverage layer (must exist in project!)
            atlas.setCoverageLayer(parcel_layer)  # Coverage layer = parcel_layer

            # Page name expression
            atlas.setPageNameExpression('"PPM"')

            # Sorting
            atlas.setSortFeatures(True)
            atlas.setSortExpression('"PPM"')

            # Single file export setting
            if hasattr(atlas, "setSingleFileExportMode"):
                # QGIS 3.26+
                atlas.setSingleFileExportMode(QgsLayoutAtlas.ExportByFeature)
            else:
                try:
                    # QGIS <= 3.24
                    atlas.setSingleFile(False)  # Single file export when possible - disabled
                except Exception:
                    # If neither available, just skip
                    self.logTextEdit.append("‚ö†Ô∏è Atlas single-file export setting skipped (not supported in this QGIS).")

            # Output filename expression
            atlas.setFilenameExpression("'Property Card_' || @atlas_featurenumber")

            # ‚úÖ Now configure "PPM location Coordinates (Table)" table
            table_frame = layout.itemById("PPM location Coordinates (Table)")
            if table_frame:
                # Get the actual attribute table object behind the frame
                table_item = table_frame.multiFrame()
                
                # Make sure your Inaccessible Point layer is already added to project before this
                inaccessible_point = QgsProject.instance().mapLayersByName(f"{parcel_layer.name()}__InaccessiblePoint")
                if inaccessible_point:
                    inaccessible_point_layer = inaccessible_point[0]

                    # Set the source of the table to the center point layer
                    table_item.setVectorLayer(inaccessible_point_layer)

                    # Keep only Easting_X and Northing_Y fields
                    fields_to_show = ["Latitude", "Longitude"]
                    table_item.setDisplayedFields(fields_to_show)

                    self.logTextEdit.append("‚úÖ Table 'PPM location Coordinates (Table)' updated with Latitude/ Longitude only.")
                else:
                    self.logTextEdit.append("‚ö†Ô∏è Inaccessible Point layer not found in project.")
            else:
                self.logTextEdit.append("‚ö†Ô∏è No table item named 'PPM location Coordinates (Table)' in template.")
                

            # ‚úÖ Delay opening the layout designer
            QTimer.singleShot(1000, lambda: self.iface.openLayoutDesigner(layout))
                
            # ‚úÖ Open layout in designer and preview first feature
            # self.iface.openLayoutDesigner(layout)
            
            self.logTextEdit.append("‚úÖ Property Card template loaded & Atlas configured successfully.")
            
        except Exception as e:
            self.logTextEdit.append(f"‚ùå Error loading QPT template or configuring Atlas: {e}")
                        
    def generate_ppms(self):
        """Full pipeline run when Generate PPMs clicked."""
        try:

            # 1. Collect user inputs
            district = self.districtComboBox.currentText().strip()
            mandal = self.mandalLineEdit.text().strip()
            village = self.villageLineEdit.text().strip()
            lgd_code = self.lgdLineEdit.text().strip()
            base_folder = self.outputFolderLineEdit.text().strip()
            photos_source = self.photosFolderLineEdit.text().strip()

            if not (district and mandal and village and lgd_code and base_folder):
                QMessageBox.warning(self, "Missing Input", "‚ö†Ô∏è Please fill all fields and select output folder.")
                return

            # 2. Create structured folder path
            # Main structured folder
            out_dir = os.path.join(base_folder,'Property Cards', district, mandal, f"{village}_{lgd_code}")
            os.makedirs(out_dir, exist_ok=True)

            # Subfolder for shapefiles
            out_dir_shapefiles = os.path.join(out_dir, "shapefiles")
            os.makedirs(out_dir_shapefiles, exist_ok=True)
            self.logTextEdit.append(f"üìÇ Output directory created: {out_dir}")
            self.logTextEdit.append(f"üìÇ Shapefiles Output directory created: {out_dir_shapefiles}")

            # ‚úÖ Switch to Log tab immediately
            try:
                # If your QTabWidget is named tabWidget and Log is the 2nd tab (index 1)
                self.tabWidget.setCurrentIndex(1)
            except Exception as e:
                print("Could not switch to Log tab:", e)
                
            # UI feedback start
            self.progressBar.setValue(0)
            self.logTextEdit.clear()
            self.logTextEdit.append("Starting PPM generation pipeline...")

            # 1) Selected parcel layer
            parcel_layer_id = self.parcelLayerComboBox.currentData()
            orig_parcel_layer = QgsProject.instance().mapLayer(parcel_layer_id)

            if orig_parcel_layer is None:
                self.logTextEdit.append("‚ùå No parcel layer selected.")
                return

            # Define output shapefile path for parcel layer
            parcel_out_path = os.path.join(out_dir_shapefiles, f"{village}_{lgd_code}.shp")

            # Save the selected layer into the structured folder
            try:
                _error, _error_msg = QgsVectorFileWriter.writeAsVectorFormat(
                    orig_parcel_layer,
                    parcel_out_path,
                    "UTF-8",
                    orig_parcel_layer.crs(),
                    "ESRI Shapefile"
                )

                if _error == QgsVectorFileWriter.NoError:
                    self.logTextEdit.append(f"‚úÖ Parcel layer saved as: {parcel_out_path}")
                else:
                    self.logTextEdit.append(f"‚ö†Ô∏è Error saving parcel layer: {_error}, {_error_msg}")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Exception saving parcel layer: {e}")
                return

            # Reload from saved shapefile so pipeline always uses this copy
            initial_parcel_layer = QgsVectorLayer(parcel_out_path, f"{village}_{lgd_code}", "ogr")
            if not initial_parcel_layer.isValid():
                self.logTextEdit.append("‚ùå Reloaded parcel layer is invalid.")
                return

            QgsProject.instance().addMapLayer(initial_parcel_layer)
            self.logTextEdit.append(f"Selected parcel layer: {initial_parcel_layer.name()}")
            self.progressBar.setValue(5)

            # Excel path from UI
            excel_path = self.excelPathLineEdit.text().strip()
            if not excel_path:
                QMessageBox.warning(self, "Missing Input", "‚ö†Ô∏è Please select an Excel file.")
                return

            # Copy Excel into out_dir
            import shutil
            excel_copy_path = os.path.join(out_dir, os.path.basename(excel_path))
            try:
                shutil.copy(excel_path, excel_copy_path)
                self.logTextEdit.append(f"‚úÖ Excel copied to: {excel_copy_path}")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error copying Excel: {e}")
                return

            # Load Excel into QGIS
            excel_uri = f"{excel_copy_path}|layername=Sheet1"   # adjust sheet name!
            owners_layer = QgsVectorLayer(excel_uri, "Owners_Excel", "ogr")

            if not owners_layer.isValid():
                self.logTextEdit.append("‚ùå Could not load Excel into QGIS. Check sheet name.")
                return

            QgsProject.instance().addMapLayer(owners_layer)
            self.logTextEdit.append(f"‚úÖ Excel loaded: {owners_layer.name()}")

            # Output joined shapefile path
            join_out_path = os.path.join(
                out_dir_shapefiles,
                f"{village}_{lgd_code}_attribute_joined.gpkg"
            )   # ‚úÖ gpkg, not shp

            try:
                self.logTextEdit.append("üîó Joining parcel layer with Excel table...")
                result = processing.run(
                    "native:joinattributestable",
                    {
                        'INPUT': initial_parcel_layer,
                        'FIELD': 'PPM',          # field in initial_parcel_layer
                        'INPUT_2': owners_layer,
                        'FIELD_2': 'PPN',        # field in excel
                        'FIELDS_TO_COPY': [],    # [] = copy all
                        'METHOD': 1,             # 1 = one-to-many
                        'DISCARD_NONMATCHING': False,
                        'OUTPUT': join_out_path
                    }
                )

                parcel_layer = QgsVectorLayer(join_out_path, f"{village}_{lgd_code}_joined", "ogr")
                if parcel_layer.isValid():
                    QgsProject.instance().addMapLayer(parcel_layer)
                    self.logTextEdit.append(f"‚úÖ Joined layer created: {join_out_path}")
                else:
                    self.logTextEdit.append("‚ùå Joined layer invalid after processing.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error during join: {e}")
                
            # 5. Copy photos folder into village folder
            photos_dest = os.path.join(out_dir, "Photos")
            if os.path.exists(photos_source):
                shutil.copytree(photos_source, photos_dest, dirs_exist_ok=True)
                self.logTextEdit.append(f"üìÇ Photos copied to: {photos_dest}")
            else:
                self.logTextEdit.append("‚ö†Ô∏è No source photos folder found.")

            # 6. Add "PhotoPath" field if not exists
            provider = parcel_layer.dataProvider()
            if "PhotoPath" not in [f.name() for f in parcel_layer.fields()]:
                provider.addAttributes([QgsField("PhotoPath", QVariant.String, len=255)])
                parcel_layer.updateFields()

            # 4. Helper to run algorithm and save as shapefile
            def run_and_save(alg, params, out_name):
                out_path = os.path.join(out_dir_shapefiles, f"{out_name}.shp")
                params['OUTPUT'] = out_path
                res = processing.run(alg, params)
                layer = QgsVectorLayer(out_path, out_name, "ogr")
                if not layer.isValid():
                    self.logTextEdit.append(f"‚ùå Failed to create {out_name}")
                else:
                    QgsProject.instance().addMapLayer(layer)
                    self.logTextEdit.append(f"‚úÖ {out_name} saved: {out_path}")
                return layer

            # 3) Boundary
            self.logTextEdit.append("1/12 ‚Üí Creating boundary...")
            # Define output file path in structured folder
            boundary_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_boundary.shp")

            params = {
                'INPUT': parcel_layer,
                'OUTPUT': boundary_path  # save to file instead of memory
            }
            res = processing.run("native:boundary", params)
            boundary_layer = QgsVectorLayer(boundary_path, f"{parcel_layer.name()}__boundary", "ogr")
            QgsProject.instance().addMapLayer(boundary_layer)
            self.logTextEdit.append(f"Boundary created and saved: {boundary_layer.name()}")

            # 4) Explode lines from boundary
            self.logTextEdit.append("2/12 ‚Üí Exploding lines from boundary...")
            # Define output path for exploded lines
            explode_lines_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_explode_lines.shp")

            res = processing.run("native:explodelines", {
                'INPUT': boundary_layer,
                'OUTPUT': explode_lines_path
            })

            # Load the saved shapefile into the project
            explode_lines = QgsVectorLayer(explode_lines_path, f"{parcel_layer.name()}__explode_lines", "ogr")
            QgsProject.instance().addMapLayer(explode_lines)

            self.logTextEdit.append(f"Explode lines created and saved: {explode_lines.name()}")
            self.progressBar.setValue(15)


            # 5) Extract vertices from boundary
            self.logTextEdit.append("3/12 ‚Üí Extracting vertices from boundary...")
            # Define output path for vertices
            vertices_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_vertices.shp")

            res = processing.run("native:extractvertices", {
                'INPUT': boundary_layer,
                'OUTPUT': vertices_path
            })

            # Load the saved vertices shapefile
            vertices = QgsVectorLayer(vertices_path, f"{parcel_layer.name()}__vertices", "ogr")
            QgsProject.instance().addMapLayer(vertices)

            self.logTextEdit.append(f"Vertices layer created and saved: {vertices.name()}")
            self.progressBar.setValue(25)


            # 6) Set rule-based symbology and labeling for parcel layer
            self.logTextEdit.append("4/12 ‚Üí Applying symbology and labeling to parcel layer...")
            try:
                # Root of rule-based renderer (no symbol)
                root_rule = QgsRuleBasedRenderer.Rule(None)

                # 6a) atlas intersection rule (transparent fill)
                exp1 = 'CASE WHEN within($geometry, @atlas_geometry)=0 THEN intersects($geometry, @atlas_geometry)=1 ELSE NULL END'
                sym1 = QgsFillSymbol.createSimple({'color': '255,255,255,0', 'outline_color': '0,0,0,0'})
                rule1 = QgsRuleBasedRenderer.Rule(sym1)
                rule1.setFilterExpression(exp1)
                rule1.setDescription('atlas_intersect')
                root_rule.appendChild(rule1)

                # 6b) PPM outline rule
                exp2 = '"PPM" = @atlas_pagename'
                fill_sym = QgsFillSymbol.createSimple({'color': '255,255,255,0'})
                outline = QgsLineSymbol.createSimple({'color': '0,0,0', 'width': '0.6'})
                try:
                    fill_sym.appendSymbolLayer(outline.symbolLayer(0).clone())
                except Exception:
                    pass
                rule2 = QgsRuleBasedRenderer.Rule(fill_sym)
                rule2.setFilterExpression(exp2)
                rule2.setDescription('PPM_outline')
                root_rule.appendChild(rule2)

                renderer = QgsRuleBasedRenderer(root_rule)
                parcel_layer.setRenderer(renderer)
                parcel_layer.triggerRepaint()

                # ---------- Rule A (PPM label) ----------
                pal_a = QgsPalLayerSettings()
                pal_a.enabled = True
                pal_a.fieldName = "\"PPM\""
                pal_a.isExpression = True
                pal_a.placement = QgsPalLayerSettings.OverPoint
                pal_a.centroidInside = True          # force label centroid inside polygon
                pal_a.priority = 10                  # high priority
                pal_a.obstacle = True                # treat features as obstacles
                pal_a.obstacleFactor = 1.0           # how strongly labels avoid obstacles

                tf_a = QgsTextFormat()
                tf_a.setFont(QFont("Arial", 15, QFont.Bold))
                # tf_a.setSize(15)   # ‚úÖ Force label size 15 pt
                tf_a.setColor(QColor('black'))

                # ‚úÖ Circular background
                bg = QgsTextBackgroundSettings()
                bg.setEnabled(True)               # enable background
                bg.setType(QgsTextBackgroundSettings.ShapeCircle)   # set circle shape
                bg.strokeWidth = 0.3
                bg.sizeType = QgsTextBackgroundSettings.SizeBuffer
                bg.setSize(QSizeF(0.5, 0.5))  # width x height in millimeters

                # Fill symbol setup
                fill_sym = QgsFillSymbol.createSimple({
                    'style': 'solid',        # stroke style
                    'color': '255,255,255,0',# transparent fill (RGBA)
                    'outline_color': '0,0,0',# stroke color black
                    'outline_width': '0.3'   # stroke width
                })
                bg.setFillSymbol(fill_sym)
             
                tf_a.setBackground(bg)

                pal_a.setFormat(tf_a)

                # ‚úÖ Dynamic label size expression
                size_expr = """
                CASE
                    WHEN "PPM" < 10 THEN 10
                    WHEN "PPM" < 100 THEN 8
                    WHEN "PPM" < 1000 THEN 6.2
                    ELSE 4.2
                END
                """

                props_a = QgsPropertyCollection()
                props_a.setProperty(QgsPalLayerSettings.Size, QgsProperty.fromExpression(size_expr))
                pal_a.setDataDefinedProperties(props_a)

                rule_a = QgsRuleBasedLabeling.Rule(pal_a, description="PPM label")
                rule_a.setFilterExpression('"PPM" = @atlas_pagename')


                # ---------- Rule B (Else label) ----------
                pal_b = QgsPalLayerSettings()
                pal_b.enabled = True
                pal_b.fieldName = "\"PPM\""
                pal_b.isExpression = True
                pal_b.placement = QgsPalLayerSettings.OverPoint
                pal_b.centroidInside = True
                pal_b.priority = 10
                pal_b.dist = 1                      # 1 mm distance
                pal_b.obstacle = True
                pal_b.obstacleFactor = 1.0

                tf_b = QgsTextFormat()
                # Create font with bold + underline
                font = QFont("Arial", 15, QFont.Bold)
                font.setUnderline(True)   # ‚úÖ underline applied here

                tf_b.setFont(font)
                # tf_b.setSize(15)   # ‚úÖ Force label size 15 pt
                tf_b.setColor(QColor('black'))
                
                pal_b.setFormat(tf_b)

                # ‚úÖ Enable data-defined size expression
                # If PPM < 10 ‚Üí 10
                # If PPM < 100 ‚Üí 8
                # If PPM < 1000 ‚Üí 6.2
                # Else ‚Üí 4.2
                # ‚úÖ Expression for size based on PPM
                size_expr = """
                CASE
                    WHEN "PPM" < 10 THEN 10
                    WHEN "PPM" < 100 THEN 8
                    WHEN "PPM" < 1000 THEN 6.2
                    ELSE 4.2
                END
                """
                # Attach data-defined property
                props = QgsPropertyCollection()
                props.setProperty(QgsPalLayerSettings.Size, QgsProperty.fromExpression(size_expr))
                pal_b.setDataDefinedProperties(props)
      
                # Create labeling rule
                rule_b = QgsRuleBasedLabeling.Rule(pal_b, description="Else label", elseRule=True)

                # Combine rules
                root_label = QgsRuleBasedLabeling.Rule(QgsPalLayerSettings())
                root_label.appendChild(rule_a)
                root_label.appendChild(rule_b)

                labeling = QgsRuleBasedLabeling(root_label)
                parcel_layer.setLabeling(labeling)
                parcel_layer.setLabelsEnabled(True)
                parcel_layer.triggerRepaint()


                self.logTextEdit.append("Parcel symbology and base labeling applied (please fine-tune labels visually).")

            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Symbology/labeling step raised an error: {e}")

            self.progressBar.setValue(35)

            # 7) Multi-ring buffer around vertices (number of rings=1, distance=2)
            # Define output path for buffer
            buffer_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_buffer.shp")

            self.logTextEdit.append("5/12 ‚Üí Creating multi-ring buffer (distance 2, rings 1) around vertices...")

            # Try native:multiringbuffer first, fallback to buffer
            try:
                res = processing.run("native:multiringbuffer", {
                    'INPUT': vertices,
                    'DISTANCE': 2,
                    'NUMBER': 1,
                    'SEGMENTS': 8,
                    'OUTPUT': buffer_path
                })
            except Exception:
                res = processing.run("native:buffer", {
                    'INPUT': vertices,
                    'DISTANCE': 2,
                    'SEGMENTS': 8,
                    'DISSOLVE': False,
                    'OUTPUT': buffer_path
                })

            # Load the saved buffer shapefile
            buffer_layer = QgsVectorLayer(buffer_path, f"{parcel_layer.name()}__buffer", "ogr")
            QgsProject.instance().addMapLayer(buffer_layer)

            self.logTextEdit.append(f"Buffer created and saved: {buffer_layer.name()}")
            self.progressBar.setValue(45)


            # 8) Clip: explode_lines (input) clipped by buffer
            # Define output path for clip layer
            clip_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_clip.shp")

            self.logTextEdit.append("6/12 ‚Üí Clipping exploded lines by buffer...")

            # Run clipping and save directly to file
            res = processing.run("native:clip", {
                'INPUT': explode_lines,
                'OVERLAY': buffer_layer,
                'OUTPUT': clip_path
            })

            # Load the saved clip shapefile
            clip_layer = QgsVectorLayer(clip_path, f"{parcel_layer.name()}__clip", "ogr")
            QgsProject.instance().addMapLayer(clip_layer)

            self.logTextEdit.append(f"Clip created and saved: {clip_layer.name()}")
            self.progressBar.setValue(55)


            # 9) Explode lines for the clip shapefile
            # Define output path for clip_explode_lines
            clip_explode_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_clip_explode_lines.shp")

            self.logTextEdit.append("7/12 ‚Üí Exploding lines from clip...")

            # Run explode lines and save directly to shapefile
            res = processing.run("native:explodelines", {
                'INPUT': clip_layer,
                'OUTPUT': clip_explode_path
            })

            # Load the saved shapefile as a layer
            clip_explode_lines = QgsVectorLayer(clip_explode_path, f"{parcel_layer.name()}__clip_explode_lines", "ogr")
            QgsProject.instance().addMapLayer(clip_explode_lines)

            self.logTextEdit.append(f"Clip explode lines created and saved: {clip_explode_lines.name()}")
            self.progressBar.setValue(60)


            # 10) Change symbology on the explode_lines (from boundary) -> rule-based with transparency 0% for PPM = @atlas_pagename
            self.logTextEdit.append("8/12 ‚Üí Applying symbology to explode lines (boundary-derived)...")
            try:
                root = QgsRuleBasedRenderer.Rule(None)
                exp_ppm = '"PPM" = @atlas_pagename'
                # create a transparent symbol (opacity 0)
                sym = QgsLineSymbol.createSimple({'color': '0,0,0', 'width': '0.26'})
                sym.setOpacity(0.0)
                rule = QgsRuleBasedRenderer.Rule(sym)
                rule.setFilterExpression(exp_ppm)
                rule.setDescription('hide_ppm')
                root.appendChild(rule)
                expl_renderer = QgsRuleBasedRenderer(root)
                explode_lines.setRenderer(expl_renderer)
                explode_lines.triggerRepaint()
                self.logTextEdit.append("Explode lines symbology applied.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Explode lines symbology error: {e}")

            self.progressBar.setValue(70)

            # 11) Add new field "length" to explode_lines and populate with $length (Decimal number, length=10, precision=2)
            self.logTextEdit.append("9/12 ‚Üí Adding 'length' field to explode lines and populating values...")
            try:
                if explode_lines.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
                    explode_lines.startEditing()
                    # create field with length and precision
                    fld = QgsField("length", QVariant.Double, '', 10, 2)
                    explode_lines.dataProvider().addAttributes([fld])
                    explode_lines.updateFields()

                    idx = explode_lines.fields().indexFromName('length')
                    for feat in explode_lines.getFeatures():
                        geom = feat.geometry()
                        if geom is None:
                            continue
                        length_value = geom.length()
                        # round to 2 decimal places for the precision
                        explode_lines.changeAttributeValue(feat.id(), idx, round(float(length_value), 2))
                    explode_lines.commitChanges()
                    self.logTextEdit.append("Length field added (Double, width=10, prec=2) and populated.")
                else:
                    self.logTextEdit.append("‚ö†Ô∏è Cannot add field to explode_lines (provider doesn't support add).")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error adding/calculating length: {e}")

            self.progressBar.setValue(75)

            # 12) Label explode_lines with length (Single Labels), with size expression and placement.
            self.logTextEdit.append("10/12 ‚Üí Applying labeling to explode lines (show 'length')...")
            try:
                pal = QgsPalLayerSettings()
                pal.enabled = True
                pal.fieldName = 'length'
                pal.isExpression = True
                pal.obstacle = True                # treat features as obstacles
                pal.obstacleFactor = 1.0
                try:
                    pal.placement = QgsPalLayerSettings.Line
                except Exception:
                    pass
                try:
                    pal.distance = 1  # mm (approx)
                except Exception:
                    pass
                text_format = QgsTextFormat()
                text_format.setFont(QFont("Arial"))
                # text_format.setSize(8)

                # Apply text format to labeling
                # Expression for dynamic font size
                size_expr = """
                CASE
                    WHEN @map_scale <= 200 THEN
                        CASE
                            WHEN "length" < 5  THEN 9
                            WHEN "length" < 10 THEN 10
                            WHEN "length" < 15 THEN 12
                            WHEN "length" < 30 THEN 13
                            WHEN "length" < 45 THEN 14
                            ELSE 15
                        END

                    WHEN @map_scale <= 500 THEN
                        CASE
                            WHEN "length" < 5  THEN 5
                            WHEN "length" < 10 THEN 6
                            WHEN "length" < 15 THEN 8
                            WHEN "length" < 30 THEN 9
                            WHEN "length" < 45 THEN 10
                            ELSE 11
                        END

                    WHEN @map_scale <= 1000 THEN
                        CASE
                            WHEN "length" < 5  THEN 4
                            WHEN "length" < 10 THEN 5
                            WHEN "length" < 15 THEN 7
                            WHEN "length" < 30 THEN 8
                            WHEN "length" < 45 THEN 9
                            ELSE 10
                        END

                    WHEN @map_scale <= 2000 THEN
                        CASE
                            WHEN "length" < 5  THEN 2
                            WHEN "length" < 10 THEN 3
                            WHEN "length" < 15 THEN 5
                            WHEN "length" < 30 THEN 6
                            WHEN "length" < 45 THEN 7
                            ELSE 8
                        END

                    ELSE
                        CASE
                            WHEN "length" < 5  THEN 2
                            WHEN "length" < 10 THEN 3
                            WHEN "length" < 15 THEN 5
                            WHEN "length" < 30 THEN 6
                            WHEN "length" < 45 THEN 7
                            ELSE 10
                        END
                END
                """

                # Attach expression to the SIZE property
                props = QgsPropertyCollection()
                props.setProperty(QgsPalLayerSettings.Size, QgsProperty.fromExpression(size_expr))
                pal.setDataDefinedProperties(props)      
                                
                # Apply to layer
                labeling = QgsVectorLayerSimpleLabeling(pal)
                explode_lines.setLabeling(labeling)
                explode_lines.setLabelsEnabled(True)
                explode_lines.triggerRepaint()
                self.logTextEdit.append("Labels applied to explode lines.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Labeling explode lines error: {e}")

            # 13) Clip explode lines symbology rule-based
            self.logTextEdit.append("11/12 ‚Üí Applying symbology to clip explode lines...")
            try:
                rootc = QgsRuleBasedRenderer.Rule(None)
                exp_clip = 'CASE WHEN within($geometry, @atlas_geometry)=0 THEN intersects($geometry, @atlas_geometry)=1 ELSE NULL END'
                symc = QgsLineSymbol.createSimple({'color': '0,0,0', 'width': '0.26'})
                rulec = QgsRuleBasedRenderer.Rule(symc)
                rulec.setFilterExpression(exp_clip)
                rulec.setDescription('clip_rule')
                rootc.appendChild(rulec)
                clip_explode_lines.setRenderer(QgsRuleBasedRenderer(rootc))
                clip_explode_lines.triggerRepaint()
                self.logTextEdit.append("Clip explode lines symbology applied.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Clip explode lines symbology error: {e}")

            self.progressBar.setValue(80)

            # 14) In vertices: add point_ID, Easting_X, Northing_Y fields and populate
            self.logTextEdit.append("12/12 ‚Üí Adding point_ID, Easting_X, Northing_Y fields to vertices and populating...")
            try:
                if vertices.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
                    vertices.startEditing()
                    # add fields if not present: point_ID (int len 10), Easting_X (double len15 prec3), Northing_Y (double len15 prec3)
                    fdefs = []
                    if vertices.fields().indexFromName("point_ID") == -1:
                        fdefs.append(QgsField("point_ID", QVariant.Int, '', 10, 0))
                    if vertices.fields().indexFromName("Easting_X") == -1:
                        fdefs.append(QgsField("Easting_X", QVariant.Double, '', 15, 3))
                    if vertices.fields().indexFromName("Northing_Y") == -1:
                        fdefs.append(QgsField("Northing_Y", QVariant.Double, '', 15, 3))
                    if fdefs:
                        vertices.dataProvider().addAttributes(fdefs)
                    vertices.updateFields()
                    idx_pid = vertices.fields().indexFromName("point_ID")
                    idx_e = vertices.fields().indexFromName("Easting_X")
                    idx_n = vertices.fields().indexFromName("Northing_Y")
                    
                    has_vertex_ind = vertices.fields().indexFromName("vertex_ind") != -1

                    # populate values: vertex index + 1, and $x/$y
                    for i, feat in enumerate(vertices.getFeatures()):
                        geom = feat.geometry()
                        if geom is None:
                            continue
                        pt = None
                        try:
                            pt = geom.asPoint()
                        except Exception:
                            try:
                                pt = geom.centroid().asPoint()
                            except Exception:
                                pt = None

                        # ‚úÖ Use vertex_ind + 1 if available
                        if idx_pid != -1:
                            if has_vertex_ind:
                                try:
                                    val = int(feat.attribute("vertex_ind")) + 1
                                    vertices.changeAttributeValue(feat.id(), idx_pid, val)
                                except Exception:
                                    # fallback: if vertex_ind not valid, use i + 1
                                    vertices.changeAttributeValue(feat.id(), idx_pid, i + 1)
                            else:
                                vertices.changeAttributeValue(feat.id(), idx_pid, i + 1)

                        if pt:
                            if idx_e != -1:
                                vertices.changeAttributeValue(feat.id(), idx_e, round(pt.x(), 3))
                            if idx_n != -1:
                                vertices.changeAttributeValue(feat.id(), idx_n, round(pt.y(), 3))
                    vertices.commitChanges()
                    self.logTextEdit.append("Vertices fields added and populated.")
                else:
                    self.logTextEdit.append("‚ö†Ô∏è Cannot add fields to vertices (provider doesn't support add).")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error adding/populating vertex fields: {e}")

            self.progressBar.setValue(85)

            # 15) Delete duplicates in vertices by (PPM, Easting_X, Northing_Y) -> manual dedupe
            self.logTextEdit.append("Removing duplicate vertices by (PPM, Easting_X, Northing_Y)...")
            try:
                # build unique key set
                seen = set()
                unique_feats = []
                fields = vertices.fields()
                ppm_idx = fields.indexFromName("PPM") if fields.indexFromName("PPM") != -1 else -1
                ex_idx = fields.indexFromName("Easting_X")
                ny_idx = fields.indexFromName("Northing_Y")

                for feat in vertices.getFeatures():
                    ppm_val = feat.attribute(ppm_idx) if ppm_idx != -1 else None
                    ex = feat.attribute(ex_idx)
                    ny = feat.attribute(ny_idx)
                    key = (ppm_val, round(float(ex) if ex is not None else 0, 3), round(float(ny) if ny is not None else 0, 3))
                    if key in seen:
                        continue
                    seen.add(key)
                    unique_feats.append(feat)

                # Define output path for no-duplicate vertices
                no_dup_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_no_dup_vertices.shp")

                # Create memory layer
                no_dup = QgsVectorLayer("Point?crs=" + vertices.crs().authid(),
                                        f"{parcel_layer.name()}__no_dup_vertices",
                                        "memory")
                no_dup_dp = no_dup.dataProvider()
                no_dup_dp.addAttributes(vertices.fields())
                no_dup.updateFields()
                no_dup.startEditing()

                for f in unique_feats:
                    newf = QgsFeature(no_dup.fields())
                    newf.setGeometry(f.geometry())
                    for idx in range(len(no_dup.fields())):
                        fldname = no_dup.fields()[idx].name()
                        newf.setAttribute(idx, f.attribute(fldname))
                    no_dup.addFeature(newf)

                no_dup.commitChanges()

                # Save the memory layer to shapefile
                _error, _error_message = QgsVectorFileWriter.writeAsVectorFormat(
                    no_dup,
                    no_dup_path,
                    "UTF-8",
                    no_dup.crs(),
                    "ESRI Shapefile"
                )

                if _error == QgsVectorFileWriter.NoError:
                    self.logTextEdit.append(f"‚úÖ No-duplicate vertices layer created and saved: {no_dup_path}")
                    # Load the saved shapefile as layer
                    no_dup_layer = QgsVectorLayer(no_dup_path, f"{parcel_layer.name()}__no_dup_vertices", "ogr")
                    QgsProject.instance().addMapLayer(no_dup_layer)

                    # --- Apply rule-based symbology to the FINAL loaded layer ---
                    rootv = QgsRuleBasedRenderer.Rule(None)
                    exp_v = '"PPM" = @atlas_pagename'
                    symv = QgsMarkerSymbol.createSimple({
                        'name': 'circle',
                        'color': '0,0,0',
                        'outline_color': '0,0,0',
                        'size': '1.00'
                    })
                    rv = QgsRuleBasedRenderer.Rule(symv)
                    rv.setFilterExpression(exp_v)
                    rv.setDescription('ppm_points')
                    rootv.appendChild(rv)

                    renderer = QgsRuleBasedRenderer(rootv)
                    no_dup_layer.setRenderer(renderer)
                    no_dup_layer.triggerRepaint()
                    self.logTextEdit.append("üé® Symbology applied to no-duplicate vertices layer.")

                    # --- Update point_ID = vertex_ind + 1 ---
                    try:
                        if no_dup_layer.isValid():
                            no_dup_layer.startEditing()
                            idx_pid = no_dup_layer.fields().indexFromName("point_ID")
                            idx_vid = no_dup_layer.fields().indexFromName("vertex_ind")

                            if idx_pid != -1 and idx_vid != -1:
                                for feat in no_dup_layer.getFeatures():
                                    try:
                                        vid = feat.attribute(idx_vid)
                                        if vid is not None:
                                            new_val = int(vid) + 1
                                            no_dup_layer.changeAttributeValue(feat.id(), idx_pid, new_val)
                                    except Exception:
                                        pass
                            no_dup_layer.commitChanges()
                            self.logTextEdit.append("üîÑ Updated point_ID = vertex_ind + 1 for no-duplicate vertices.")
                    except Exception as e:
                        self.logTextEdit.append(f"‚ö†Ô∏è Error updating point_ID: {e}")

                else:
                    self.logTextEdit.append(f"‚ö†Ô∏è Error saving no-duplicate vertices layer: {_error}, {_error_message}")

            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error in duplicate-removal: {e}")

            self.progressBar.setValue(90)


            # 16) Apply rule-based symbology to no-duplicate vertices (simple marker black 1.00 mm where PPM=@atlas_pagename)
            try:
                rootv = QgsRuleBasedRenderer.Rule(None)
                exp_v = '"PPM" = @atlas_pagename'
                symv = QgsMarkerSymbol.createSimple({'name': 'circle', 'color': '0,0,0', 'outline_color': '0,0,0', 'size': '1.00'})
                rv = QgsRuleBasedRenderer.Rule(symv)
                rv.setFilterExpression(exp_v)
                rv.setDescription('ppm_points')
                rootv.appendChild(rv)
                no_dup.setRenderer(QgsRuleBasedRenderer(rootv))
                no_dup.triggerRepaint()
                self.logTextEdit.append("No-duplicate vertices symbology applied.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error applying symbology to no-dup vertices: {e}")

            # 17) Uncheck/hide temporary layers (buffer, clip, boundary, vertices, orig_parcel_layer, initial_parcel_layer)
            self.logTextEdit.append("Hiding intermediate layers (buffer, clip, boundary, vertices, original parcel layer)...")
            try:
                for lay in (buffer_layer, clip_layer, boundary_layer, vertices, orig_parcel_layer, initial_parcel_layer):
                    if lay:
                        node = QgsProject.instance().layerTreeRoot().findLayer(lay.id())
                        if node:
                            node.setItemVisibilityChecked(False)
                self.logTextEdit.append("Intermediate layers (and original parcel layer) hidden.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Hide intermediate layers error: {e}")


            # 18) Reorder layers: no_dup_vertices, parcel_area, clip_explode_lines, explode_lines
            self.logTextEdit.append("Reordering layers...")
            try:
                root = QgsProject.instance().layerTreeRoot()
                layer_order = [no_dup.id(), parcel_layer.id(), clip_explode_lines.id(), explode_lines.id()]
                # move so that first in list becomes top
                for i, lid in enumerate(layer_order):
                    layer = QgsProject.instance().mapLayer(lid)
                    if layer:
                        node = root.findLayer(lid)
                        if node:
                            root.insertChildNode(i, node.clone())
                            root.removeChildNode(node)
                self.logTextEdit.append("Layer order updated.")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error reordering layers: {e}")

            # # 19) Point on surface for parcel_area
            # self.logTextEdit.append("Generating center point (point on surface) for parcel area...")

            # # Build output path
            # center_point_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_center_point.shp")

            # try:
            #     res = processing.run("native:pointonsurface", {
            #         'INPUT': parcel_layer,
            #         'OUTPUT': center_point_path
            #     })

            #     # Load saved center point layer
            #     center_point = QgsVectorLayer(center_point_path, f"{parcel_layer.name()}__center_point", "ogr")
            #     if not center_point.isValid():
            #         raise Exception("Center point layer failed to load!")

            #     QgsProject.instance().addMapLayer(center_point)
            #     self.logTextEdit.append(f"‚úÖ Center point created and saved: {center_point_path}")

            #     # --- Step 20: styling & fields for center_point ---
            #     try:
            #         if center_point.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
            #             center_point.startEditing()
            #             fdefs = []
            #             if center_point.fields().indexFromName("point_ID") == -1:
            #                 fdefs.append(QgsField("point_ID", QVariant.Int, '', 10, 0))
            #             if center_point.fields().indexFromName("Easting_X") == -1:
            #                 fdefs.append(QgsField("Easting_X", QVariant.Double, '', 15, 3))
            #             if center_point.fields().indexFromName("Northing_Y") == -1:
            #                 fdefs.append(QgsField("Northing_Y", QVariant.Double, '', 15, 3))
            #             if fdefs:
            #                 center_point.dataProvider().addAttributes(fdefs)
            #             center_point.updateFields()

            #             idx_pid = center_point.fields().indexFromName("point_ID")
            #             idx_e = center_point.fields().indexFromName("Easting_X")
            #             idx_n = center_point.fields().indexFromName("Northing_Y")

            #             has_vertex_ind = center_point.fields().indexFromName("vertex_ind") != -1
            #             for i, feat in enumerate(center_point.getFeatures()):
            #                 geom = feat.geometry()
            #                 if not geom:
            #                     continue
            #                 try:
            #                     pt = geom.asPoint()
            #                 except Exception:
            #                     try:
            #                         pt = geom.centroid().asPoint()
            #                     except Exception:
            #                         pt = None

            #                 if idx_pid != -1:
            #                     if has_vertex_ind:
            #                         try:
            #                             val = int(feat.attribute("vertex_ind")) + 1
            #                             center_point.changeAttributeValue(feat.id(), idx_pid, val)
            #                         except Exception:
            #                             center_point.changeAttributeValue(feat.id(), idx_pid, i + 1)
            #                     else:
            #                         center_point.changeAttributeValue(feat.id(), idx_pid, i + 1)
            #                 if pt:
            #                     if idx_e != -1:
            #                         center_point.changeAttributeValue(feat.id(), idx_e, round(pt.x(), 3))
            #                     if idx_n != -1:
            #                         center_point.changeAttributeValue(feat.id(), idx_n, round(pt.y(), 3))

            #             center_point.commitChanges()

            #         # üé® Styling
            #         red = QgsMarkerSymbol.createSimple({'name': 'circle', 'size': '2.0', 'color': '#ff0000'})
            #         white = QgsMarkerSymbol.createSimple({'name': 'circle', 'size': '1.0',
            #                                             'color': '255,255,255', 'outline_color': '0,0,0'})

            #         symbol = red.clone()
            #         symbol.appendSymbolLayer(white.symbolLayer(0).clone())

            #         rootp = QgsRuleBasedRenderer.Rule(None)

            #         # ‚úÖ safer filter: only apply if "PPM" exists
            #         if center_point.fields().indexFromName("PPM") != -1:
            #             rulep = QgsRuleBasedRenderer.Rule(symbol)
            #             rulep.setFilterExpression('"PPM" = @atlas_pagename')
            #             rulep.setDescription('center_ppm')
            #             rootp.appendChild(rulep)
            #         else:
            #             # fallback: show all points if PPM field missing
            #             rulep = QgsRuleBasedRenderer.Rule(symbol)
            #             rulep.setDescription('all_points')
            #             rootp.appendChild(rulep)

            #         renderer = QgsRuleBasedRenderer(rootp)
            #         center_point.setRenderer(renderer)
            #         center_point.triggerRepaint()

            #         self.logTextEdit.append("üé® Center point symbology applied.")

            #     except Exception as e_cp_field:
            #         self.logTextEdit.append(f"‚ö†Ô∏è Error adding/populating center point fields: {e_cp_field}")

            # except Exception as e:
            #     self.logTextEdit.append(f"‚ö†Ô∏è Point on surface error: {e}")



            # --- Step XX: Pole of Inaccessibility ---
            self.logTextEdit.append("Generating Pole of Inaccessibility (PoI) for parcel area...")

            poi_path = os.path.join(out_dir_shapefiles, f"{parcel_layer.name()}_InaccessiblePoint.shp")

            try:
                # Run Pole of Inaccessibility
                res = processing.run("native:poleofinaccessibility", {
                    'INPUT': parcel_layer,
                    'TOLERANCE': 1.0,
                    'DISTANCE_UNITS': 0,   # 0 = meters
                    'AREA_UNITS': 0,       # 0 = m2
                    'OUTPUT': poi_path
                })

                poi_layer = QgsVectorLayer(res['OUTPUT'], f"{parcel_layer.name()}__InaccessiblePoint", "ogr")
                if not poi_layer.isValid():
                    raise Exception("PoI layer failed to load!")

                # Add to project
                QgsProject.instance().addMapLayer(poi_layer)
                
                # Move to bottom
                root = QgsProject.instance().layerTreeRoot()
                node = root.findLayer(poi_layer.id())
                if node:
                    root.insertChildNode(-1, node.clone())  # insert at bottom
                    root.removeChildNode(node)               # remove original node

                self.logTextEdit.append(f"‚úÖ PoI created and saved: {poi_path}")

                # --- Add Latitude/Longitude fields ---
                if poi_layer.dataProvider().capabilities() & QgsVectorDataProvider.AddAttributes:
                    poi_layer.startEditing()
                    fdefs = []
                    if poi_layer.fields().indexFromName("Latitude") == -1:
                        fdefs.append(QgsField("Latitude", QVariant.Double, '', 10, 6))
                    if poi_layer.fields().indexFromName("Longitude") == -1:
                        fdefs.append(QgsField("Longitude", QVariant.Double, '', 10, 6))
                    if fdefs:
                        poi_layer.dataProvider().addAttributes(fdefs)
                    poi_layer.updateFields()

                    idx_lat = poi_layer.fields().indexFromName("Latitude")
                    idx_lon = poi_layer.fields().indexFromName("Longitude")

                    # Transform to WGS84 for lat/lon
                    crs_src = poi_layer.crs()
                    crs_dest = QgsCoordinateReferenceSystem("EPSG:4326")
                    xform = QgsCoordinateTransform(crs_src, crs_dest, QgsProject.instance())

                    for feat in poi_layer.getFeatures():
                        geom = feat.geometry()
                        if geom:
                            pt = geom.asPoint()
                            pt_wgs = xform.transform(pt)
                            poi_layer.changeAttributeValue(feat.id(), idx_lat, round(pt_wgs.y(), 6))
                            poi_layer.changeAttributeValue(feat.id(), idx_lon, round(pt_wgs.x(), 6))

                    poi_layer.commitChanges()

                # --- Styling: fully transparent with rule '"PPM" = @atlas_pagename' ---
                symbol = QgsMarkerSymbol.createSimple({
                    'name': 'circle',
                    'size': '2.0',
                    'color': '0,0,0,0',
                    'outline_color': '0,0,0,0'
                })

                rootp = QgsRuleBasedRenderer.Rule(None)
                if poi_layer.fields().indexFromName("PPM") != -1:
                    rulep = QgsRuleBasedRenderer.Rule(symbol)
                    rulep.setFilterExpression('"PPM" = @atlas_pagename')
                    rulep.setDescription('poi_ppm')
                    rootp.appendChild(rulep)
                else:
                    rulep = QgsRuleBasedRenderer.Rule(symbol)
                    rulep.setDescription('poi_all')
                    rootp.appendChild(rulep)

                renderer = QgsRuleBasedRenderer(rootp)
                poi_layer.setRenderer(renderer)
                poi_layer.triggerRepaint()

                self.logTextEdit.append("üé® PoI symbology applied.")

            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error generating PoI: {e}")



            try:
                project = QgsProject.instance()
                project_filename = os.path.join(out_dir, f"{village}_{lgd_code}_PropertyCard.qgz")
                project.write(project_filename)
                self.logTextEdit.append(f"üíæ QGIS project saved: {project_filename}")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error saving QGIS project: {e}")

            # Copy Blank_Photo.png to output folder if not already present
            plugin_dir = os.path.dirname(os.path.abspath(__file__))
            blank_photo_src = os.path.join(plugin_dir, "Blank_Photo.png")
            blank_photo_dest = os.path.join(photos_dest, "Blank_Photo.png")

            if not os.path.exists(blank_photo_dest):
                shutil.copy(blank_photo_src, blank_photo_dest)

            # Update each feature with photo path (relative to project path)
            parcel_layer.startEditing()
            project_dir = os.path.dirname(QgsProject.instance().fileName())
                            
            for feature in parcel_layer.getFeatures():
                ppm_value = str(feature["PPM"]).strip()
                if not ppm_value:
                    continue

                candidates = [
                    os.path.join(photos_dest, f"{ppm_value}.jpg"),
                    os.path.join(photos_dest, f"{ppm_value}.jpeg"),
                    os.path.join(photos_dest, f"{ppm_value}.JPG"),
                    os.path.join(photos_dest, f"{ppm_value}.JPEG"),
                ]

                photo_file = None
                for c in candidates:
                    if os.path.exists(c):
                        # ‚úÖ store as relative path (relative to project directory)
                        rel_path = os.path.relpath(c, project_dir).replace("\\", "/")
                        photo_file = rel_path
                        break

                # If still no photo found ‚Üí use Blank_Photo.png
                if not photo_file:
                    rel_path = os.path.relpath(blank_photo_dest, project_dir).replace("\\", "/")
                    photo_file = rel_path

                # ‚úÖ Update feature
                parcel_layer.changeAttributeValue(
                    feature.id(),
                    parcel_layer.fields().indexFromName("PhotoPath"),
                    photo_file
                )

            parcel_layer.commitChanges()


            self.logTextEdit.append("‚úÖ Photo paths added to parcel layer successfully.")
            self.progressBar.setValue(95)
            
            # Load QPT layout template
            qpt_path = os.path.join(os.path.dirname(__file__), "PropertyCard_SINGLE_SVAMITVA.qpt")
            self.load_qpt_template(qpt_path, parcel_layer)
            self.logTextEdit.append(f"üëç QGIS Template saved: PropertyCard_SINGLE_SVAMITVA.qpt")

            # --- Save project again so the layout persists ---
            try:
                project = QgsProject.instance()
                project_filename = os.path.join(out_dir, f"{village}_{lgd_code}_PropertyCard.qgz")
                project.write(project_filename)
                self.logTextEdit.append(f"üíæ QGIS project re-saved with layout: {project_filename}")
            except Exception as e:
                self.logTextEdit.append(f"‚ö†Ô∏è Error re-saving QGIS project: {e}")
                
            self.progressBar.setValue(100)
            self.logTextEdit.append("‚úÖ PPM generation pipeline completed.")

        except Exception as e:
            self.logTextEdit.append(f"‚ùå Unexpected error: {e}")
            raise